
# Problem 3: Rearrange Array Digits

To solve this problem we first need to sort the unsorted list, then we need to move through the list in descending order where we concatenate the integers into two seperate numbers, which are then packaged as the final returned tuple representing the maximum sum possible. By alternating between largest number added to num1 variable, then second largest added to num2 variable, and continuing on in this fashion, we guarantee the maximum sum of two numbers.

The main issue is to decide on the sorting algorithm to use, which has a worst case time complexity of $O(n\log(n))$. Here I looked at the following possible algorithms to use: merge sort, quicksort, and heapsort. I decided to go with heapsort for the following reasons. Heapsort sorts in place, which gives us a space complexity of `O(1)`, and it has a best/worst case time complexity of $O(n\log(n))$. Quicksort can also sort in place keeping the time complexity at `O(1)`, but it's worst case time complexity, when dealing with a fully sorted list, falls to $O(n^2)$ time complexity. Since some of our test cases had fully sorted arrays filled with the same number, this seemed like a less optimal solution than heapsort which guarantees the needed $O(n\log(n))$ time complexity regardless if an array is already sorted. When comparing to merge sort, merge sort satisfies the time complexity of $O(n\log(n))$, but has a worst space complexity of `O(n)` as opposed to our heapsort solution with space complexity of `O(1)`.

My use of the heapsort algorithm sorts the array in $O(n\log(n))$ time while the final for loop that assembles the returned tuple of numbers is done in `O(n)` time. $O(n\log(n)) + O(n)$ will still leave us with final time complexity of $O(n\log(n))$.

**NOTE**
I changed two provided test cases for this problem, because these test cases made no logical sense, and broke the required criteria for solving this problem. One such test case provided the array/solution [2, 2, 2, 2, 2] --> [222, 2], which is wrong, since the rule states the numbers returned have a number of digits differing by no more than one. You can't have an array of 5 items return a tuple where the first item is 3 digits and the second is 1 digit. The other issue was in the array/solution [3, -2, 1, -4, 5] --> [531, -42]. If we need to deal with negative numbers, then the proper solution would be [531, -24]. Since this makes no sense, I simply made my code handle absolute values instead. The problem statement said to assume the numbers were in the range of [0, 9], which tells me they are positive integers. Furthermore, if we were to deal with negative numbers, then an explanation of various edge cases would need to be added to the problem statement. How would one deal with an array of 7 items where only one item is negative? How does one concatenate a positive integer with an negative integer? Would we then break the rule where the numbers formed have a number of digits differing by more than one? I simply fixed these test cases to comply with the given critera of the problem statement, and avoided dealing with negative numbers because there's no clear approach to dealing with negative numbers without clear rules as to the type of data being passed in with expected output.
